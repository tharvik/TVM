%Describe in a few words what you did in the first part of the compiler project
%(the non-optional labs), and briefly say what problem you want to solve with
%your extension.
We implemented the Tool programming language by writing a compiler in Scala.
Creating a lexer, building the AST, type checking and byte code generation,
targetted at the Java virtual machine. Now that we have the main component, we
want to also improve the others aspects of the workflow, mainly the runtime
part.

%This section should convince us that you have a clear picture of the general
%architecture of your compiler and that you understand how your extension fits
%in it.
Our extension fit at the very end of the compiler, even after it, by taking the
resulting bytecode and executing it, effectively translating the push and
println to stack modification and syscalls. The idea was not to modify the
generated bytecode but rather use it directly and thus, being able to extend and
read any Java bytecode. Actually, we are able to execute any bytecode generated
form the reference Tool compiler, and we can easily extend to support new
bytecodes should these arise. As Tool use a somewhat restricted instruction set,
we only implemented these. As type checking and name resolution were already
done, there should not be any check at the virtual machine level, but it is
recommended to add some checks and encapsulation during the bytecode run.
